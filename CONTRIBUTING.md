# 기여

## 과정

아시는 분은 이 과정대로 진행하시면 됩니다.

0. [레포 클론](#0.-레포를-클론합니다)
1. [브랜치 생성](#1.-브랜치를-만듭니다)
2. [커밋](#2.-안에서작업한-후-커밋합니다)
3. [푸시](#3.-커밋들을-깃허브에-푸시합니다)
4. [PR 생성](#4.-PR(풀-리퀘스트)를-생성합니다)
5. [브랜치 삭제](#5.-브랜치를-삭제합니다)

[예외 상황](#E.-예외-상황)

### 0. 레포를 클론합니다

아래 명령어를 입력하시면, 봇의 소스코드가 담긴 `WhiteBot` 폴더가 생성됩니다.

```
cd <WhiteBot 폴더가 생성될 디렉토리>
git clone https://github.com/dev-White-team/WhiteBot.git
```

### 1. 브랜치를 만듭니다

에디터나 IDE의 깃 툴이나 외부 깃 툴(깃헙 데스크탑 등)을 사용하고 계시다면, 그 툴의 사용법에 따라 브랜치를 새로 생성해줍니다.  
터미널을 사용하신다면 `git branch -c main <새로운 브랜치명>`을 입력하시면 됩니다.
만드신 브랜치는 작업 브랜치라고 부르겠습니다.

브랜치에서 작업할 내용이 버그 수정인 경우 `bug/<버그 요약>`, 기능 추가인 경우 `feature/<기능 이름>` 형식으로 브랜치명을 정하시면 됩니다.  
브랜치명을 잘못 정하신 경우는 [아래](#E1.-브랜치명을-잘못-정한-경우)에서 다루겠습니다.

### 2. 안에서 작업한 후 커밋합니다

작업 브랜치로 이동하신 후(`git checkout <브랜치명>`), 원하시는 대로 코드를 수정하시면 됩니다.  
꼭 브랜치 이동 후 작업해주세요. 이동하지 않고 다른 브랜치에서 작업한 경우는 [아래](#E2.-작업-브랜치가-아닌-다른-브랜치에서-작업한-경우)서 다룹니다.

### 2.1. 스테이징

스테이징은 커밋 전에 하는 준비 작업으로 커밋에 반영할 수정사항을 선택해두는 것이라고 보실 수 있겠습니다.  
반영할 내용을 선택하는 범위는 기본적으로 파일입니다(줄 별로 반영여부를 선택하는 것도 가능하지만 길어지므로 다루지 않겠습니다).  
터미널에서는 `git add <파일명>`하시면 그 파일의 수정사항이 스테이징됩니다.  
수정한 파일이 여러 개일 경우 `git add *`을 통해 모든 수정 사항을 한 번에 스테이징 할 수 있습니다.  
일부 깃 툴들의 경우에는 파일을 체크하는 것으로 스테이징을 대신합니다(깃헙 데스크탑, 파이참 내부 깃 툴).

### 2.2. 커밋

커밋은 `git commit`을 실행하시면 됩니다. 이전에 스테이징한 수정사항들이 `.git` 폴더에 저장됩니다.  
명령어를 실행하면 터미널에서 vim 에디터가 열리고 커밋 메시지 입력해야합니다.  
vim 에디터 사용법은 아래서 다루겠습니다.

커밋 메시지는 제목과 설명 두 부분으로 구성됩니다.

* 제목: 커밋이 어떤 것인지 한 줄로 요약해놓은 것입니다(50자 이내)
* 설명: 커밋 상세 내용에 보이는 부분으로 이 커밋에서 어떤 것을 수정했는지, 그 이유는 뭔지 등을 쓰시면 됩니다(줄 당 72자 이내)

커밋 제목만 쓰셔도 무방하나, 커밋 설명을 써놓으면 나중에 알아보기 편하므로 쓰시는 것을 추천드립니다.  
커밋 제목만 쓰실 경우에는 `git commit -m <커밋 제목>`를 사용하시면 vim 에디터가 열리지 않고 바로 커밋됩니다.

커밋 메시지 예시는 아래와 같습니다(16a414b 커밋).

```
날짜 변경시 Papago API 제한 해제 구현                                                            => 제목

Papago API 일일 허용량이 초과되면, is_papago_limited를 이용해 구글 번역 API를 사용하도록 처리합니다.
따라서, 날짜가 바뀌는 자정에는 is_papago_limited가 재설정되어야 합니다.
이 내용을 asyncio를 통해 구현하였으며,
처음에 봇을 시작한 경우 자정까지 남은 시간을 계산하여 딜레이한 후 재설정하고
그 후로는 24시간씩 딜레이하고 재설정하도록 하였습니다.
현재 말일에 봇을 시작할 경우 오류가 발생하는 문제가 있으며, 추후에 수정하여야합니다.
```

커밋은 한 브랜치에서 언제나 가능합니다.  
작업이 모두 끝나신 뒤에 하셔도 되고, 작업 한 단위 한 단위마다 하셔도 됩니다.

### 3. 커밋들을 깃허브에 푸시합니다

푸시는 `git push origin <작업 브랜치>`을 하시면 됩니다.  
깃허브에 커밋들이 올라갑니다. 올라간 커밋들은 수정하면 안됩니다.

컨플릭트가 나는 경우에는 먼저 `git pull origin <작업 브랜치>` 실행하여 컨플릭트를 해결하고, 다시 푸시하시면 됩니다.  
컨플릭트를 해결하는 방법은 [아래](#E5.-컨플릭트-해결하기)서 확인해주세요.

### 4. PR(풀 리퀘스트)를 생성합니다

브랜치에서 할 작업이 모두 끝나면, 프로덕션에 반영하기 위해 PR을 작성해야합니다.  
`Pull Requests` 탭에서 `Create Pull Requests`로 들어간 뒤, `base`는 `main`으로, `compare`는 작업 브랜치로 선택하신 뒤, PR을 만드시면 됩니다.  
PR의 내용은 자유이고 한두줄 정도로 짧게 쓰셔도 되지만, 그 내용에 어떤 것을 수정했는지, 수정한 이유는 무엇인지 등을 기재해주시면 좋습니다.  
이 내용에 관한 이슈가 있는 경우 해당 이슈를 맨션(`#<이슈번호>`)하는 것으로 수정한 이유를 대신하시면 됩니다.  
특히, 해당 이슈가 이 PR로 해결되는 경우에는 `Resolves #xx`을 하시면, PR이 머지될 때, 자동으로 이슈가 닫히게 할 수 있습니다.

PR의 제목은 꼭 이 PR이 어떤 내용인지 알 수 있게 작성해주세요.  
`Reviewer`는 PR 담당인 화범님, Chnrit님, 기찬 중에 한 명을 선택하시면 되고, `Assignee`는 자신을 선택하시면 됩니다.  
태그는 맞는 것을 선택하셔도 되고 하지 않으셔도 됩니다.

리뷰어는 코드를 살펴본 후에 수정할 사항을 줄 수 있습니다.  
그 내용이 합당하다고 생각하시면 수정하셔서 원래 하시던대로 푸시하시면 되고, 합당하지 않다고 생각하시면 아래 댓글을 달아 리뷰어분과 토론할 수 있습니다.  
리뷰어가 코드에서 고칠게 없다고 판단하면, PR를 승인해줄 것입니다.  
승인을 받으면 머지 버튼을 눌러, 메인에 머지하시면 됩니다(리뷰어가 바로 머지하는 것은 지양합시다).

PR에서 메인과 컨플릭트가 날 수 있습니다.  
이 경우 메인을 작업 브랜치에 머지한 후(작업 브랜치에서 `git merge main`), [아래](#E5.-컨플릭트-해결하기)을 참고하시면 됩니다.

### 5. 브랜치를 삭제합니다

메인에 머지하고나면 이제 브랜치는 필요가 없습니다. 아래 브랜치 지우기 버튼을 눌러 브랜치를 지워줍시다.  
로컬에서도 삭제해주어야합니다(`git branch -d <브랜치명>`; 실행 전에 꼭 다른 브랜치로 체크아웃해주세요).  
이제 작업이 끝났습니다. 다른 작업을 맡아서 진행하시면 됩니다.

## E. 예외 상황

1. [브랜치명을 잘못 정한 경우](#E1.-브랜치명을-잘못-정한-경우)
2. [작업 브랜치가 아닌 다른 브랜치에서 작업한 경우](#E2.-작업-브랜치가-아닌-다른-브랜치에서-작업한-경우)
3. [VIM 에디터 사용법](#E3.-VIM-에디터-사용법)
4. [커밋 메시지 수정하기](#E4.-커밋-메시지-수정하기)
5. [컨플릭트 해결하기](#E5.-컨플릭트-해결하기)
6. [stash 사용하기](#E6.-stash-사용하기)
7. [커밋 합치기](#E7.-커밋-합치기)

### E1. 브랜치명을 잘못 정한 경우

### E1.1. 깃허브에 브랜치가 생성되지 않은 경우

이 경우에는 그냥 `.git`에 저장되어 있는 브랜치 이름만 바꾸면 됩니다.

```
git branch -m <기존 이름> <새로운 이름>
```

### E1.2. 깃허브에 브랜치가 생성된 경우

한 번이라도 푸시를 해서 깃허브에 브랜치가 올라와 버린 경우에는, 일단 깃허브에 올라간 브랜치 이름을 바꿔주어야합니다.  
깃허브에 있는 브랜치 이름을 바꿨다면, 아래 명령어를 차례대로 입력해주세요.

```
git branch -m <기존 이름> <새로운 이름>
git fetch origin
git branch -u origin/<새로운 이름> <새로운 이름>
```

### E2. 작업 브랜치가 아닌 다른 브랜치에서 작업한 경우

현재 브랜치의 이름은 `git branch -l`로 확인할 수 있습니다.  
브랜치 목록이 뜨는데, 앞에 `*`이 붙어있는 브랜치가 현재 브랜치입니다.

현재 브랜치의 커밋 로그는 `git log`로 볼 수 있습니다.

### E2.1. 커밋을 안 한 경우

이 경우에는 그냥 이동만 하면 됩니다. 수정한 내용은 알아서 따라갑니다.

```
git checkout <작업 브랜치>
```

### E2.2. 커밋을 n번 한 경우

체리픽은 잘못된 브랜치로 간 커밋을 복사해가져오는 명령어입니다.  
작업 브랜치로 커밋을 복사해온 후, 다른 브랜치에서 커밋들을 삭제합니다.  
**삭제한 커밋을 복구하는 작업은 까다로우니 꼭 커밋 복사 후 확인하세요.**

```
git checkout <작업 브랜치>
git cherry-pick <다른 브랜치>~n
git log -> 커밋들이 잘 복사되었는지 확인하세요
git checkout <다른 브랜치>
git reset --hard HEAD~n
```

### E3. VIM 에디터 사용법

VIM 에디터가 처음 나타나면 명령 모드 상태입니다.  
이 상태에서 `i` 키를 눌러주면 삽입 모드가 됩니다.  
삽입 모드에서는 일반 에디터처럼 편하게 내용을 입력할 수 있습니다.  
내용을 다 입력하고나서 `esc` 키를 눌러주면 다시 명령 모드로 돌아옵니다.  
여기서 `:wq`를 입력하고 엔터를 누르면 저장하고 에디터를 닫습니다.

### E4. 커밋 메시지 수정하기

### E4.1. 가장 최근의 커밋인 경우

```
git commit --amend
```

위 명령어를 입력하시면 커밋 메시지가 있는 vim 에디터가 열립니다.  
[사용법](#E3.-VIM-에디터-사용법)에 따라 수정하시고 닫으시면 메시지가 수정됩니다.  
참고로 현재 스테이징된 수정사항이 있는 상태에서 실행하시면, 수정사항이 이 커밋에 융합됩니다.  
현재 스테이징된 내용이 반영되기를 원치 않으신다면 `stash` 후 실행하시면 됩니다.  
`stash` 사용법은 [아래](#E6.-stash-사용하기)서 다룹니다.

### E4.2. 가장 최근 커밋이 아니거나 여러 커밋의 메시지를 수정하는 경우

```
git rebase -i HEAD~n
```

여기서 `n`은 수정하려는 커밋이 위에서부터 몇 번째인지를 보시면 됩니다.  
예를 들어, 지금 수정하려는 커밋 위에 다른 커밋이 2개가 있다면 `n`는 3으로 하면 됩니다.  
여러 커밋의 메시지를 수정할 경우에는 수정하려는 커밋들 중 가장 오래된 커밋이 위에서부터 몇 번째인지를 세면 됩니다.

저 명령어를 실행하면 `pick xxxxxx <커밋 메시지>` n개가 나타나게됩니다.  
수정하려는 커밋의 앞에 `pick`을 vim 사용법에 따라 `r` 또는 `reword`로 바꿔주시면 됩니다.  
그러고나서 에디터를 닫으면 커밋 메시지를 수정할 수 있는 vim 에디터가 나타납니다.  
여기서 수정하시고 닫으시면 메시지가 수정됩니다.

### E5. 컨플릭트 해결하기

컨플릭트는 내가 수정한 부분과 다른 분이 수정한 부분이 같아 충돌이 일어난 상태를 말합니다.  
머지 같은 작업을 할 때 발생하는데, 이 경우 충돌이 일어난 부분을 보고 고쳐주어야합니다.

###### 컨플릭트가 발생했을 때의 표시

```
>>>>>> HEAD
내가 수정한 코드
======
다른 분이 수정한 코드
>>>>>> xxxxxxx
```

이 경우 내가 수정한 코드와 다른 분이 수정한 코드 중 하나를 사용하거나, 둘을 잘 섞어주면 됩니다.  
잘 수정하여 `>>>>> HEAD`, `=======`, `>>>>>> xxxxxx`를 없애면 컨플릭트는 해소됩니다.  
모든 컨플릭트를 해소한 뒤 `git merge --continue`를 실행해주시면 됩니다.
혹시라도 머지를 취소하고 싶으시다면 `git merge --abort`을 실행해주시면 됩니다.

컨플릭트는 한 번 나면 굉장히 귀찮고 시간도 많이 잡아먹습니다.  
그렇기 때문에 최대한 피할 수 있도록, **작업을 시작하기 전에 항상 `git fetch origin`을 실행해보시고**  
**내려받을 커밋이 있다고 뜨면 `git pull origin <작업 브랜치>`을 실행하여 다른 분이 올려놓은 커밋을 받아야합니다.**  
이것저것 수정해놓고 푸시하다가 컨플릭트가 발생하면 눈물을 머금고 컨플릭트를 해결해야할 수 있습니다.

### E6. stash 사용하기

`stahs` 명령어는 스테이징된 수정사항을 잠시 저장해두는 것을 뜻합니다.  
머지나 리베이스, 체크아웃 등을 할 때, 스테이징된 내용이 있으면 안 되는데, 이때 스테이징을 사용합니다.  

1. stash 목록 확인: `git stash list`

2. 수정사항 저장: `git stash save` 혹은 `git stash`  
`-m <메시지>`를 추가하여 어떤 수정사항인지 표시해둘 수 있습니다.

3. 불러오기: `git stash apply <stash ref>` 혹은 `git stash pop <stash ref>`  
`apply`는 `stash`는 놔둔채로 불러오기만 하며, `pop`은 불러온 후 해당 `stash`를 삭제합니다.  
`stash ref`는 stash 목록에 뜨는 `stash@{<번호>}` 형식을 뜻합니다. 명시하지 않으면 가장 최근에 저장된 stash를 불러옵니다.

4. 삭제: `git stash drop <stash ref>`
마찬가지로 `stash ref`는 stash 목록에 뜨는 `stash@{<번호>}` 형식을 뜻합니다. 명시하지 않으면 가장 최근에 저장된 stash를 삭제합니다.

5. 파일 하나의 수정사항만 저장: `git stash push <파일명>`  
마찬가지로 `-m <메시지>`를 추가하여 어떤 수정사항인지 표시해둘 수 있습니다.

### E7. 커밋 합치기

```
git rebase -i HEAD~n
```

여기서 `n`은 합치려는 커밋들 중 가장 오래된 커밋이 위에서부터 몇 번째인지를 세면됩니다.
저 명령어를 실행하면 `pick xxxxxx <커밋 메시지>` n개가 vim 에디터에 나타나게됩니다.  
합치려는 커밋들 중 아래 커밋의 `pick`을 vim 사용법에 따라 `s` 또는 `squash`로 바꿔주시면 됩니다.  
그러고나서 에디터를 닫으면 커밋 메시지를 수정할 수 있는 vim 에디터가 나타납니다.  
여기서 수정하시고 닫으시면 수정하신 메시지로 두 커밋이 합쳐집니다.
